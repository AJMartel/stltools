#! /usr/bin/env python
# -*- python coding: utf-8 -*-
# Program for converting a view of an STL file into a PostScript file
#
# Copyright © 2011 R.F. Smith <rsmith@xs4all.nl>. All rights reserved.
# Time-stamp: <2011-04-11 01:30:07 rsmith>
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

import sys
import string
import time
import math
import stl

ver = "stl2ps 1 beta1"

def usage():
    print ver
    print "Usage: stl2ps infile [outfile]"

class Zpar:
    '''Class for parallel projection along the Z-axis. 
       Screen coordinates from left top.'''
    def __init__(self, xmin, xmax, ymin, ymax):
        '''Initialize the projection for an object in the rectangle, 
           xmin, xmax, ymin, ymax, to a target window of 100x100 mm.'''
        # 100 mm is 100/25.4*72 = 283.46457 PostScript points
        self.s = min(283.46457/(xmax-xmin), 283.46457/(ymax-ymin))
        self.w = math.ceil(self.s*(xmax-xmin))
        self.h = math.ceil(self.s*(ymax-ymin))
        self.xo = self.w/2
        self.yo = self.h/2 
        # FIXME!
    def xformv(self, v):
        '''Transforms a Vector. Returns an (x,y) tuple'''
        x = self.s*v.x+self.xo
        y = self.yo-self.s*v.y
        return (x,y)
    def visible(self, n):
        '''Checks a Normal Vector to see if it points toward or away from the
           viewer. Returns True in the first case.'''
        if (n.z > 0.0): return True
        return False

# This is the main program
if len(sys.argv) == 1:
    usage()
    sys.exit(0)
try:
    stlobj = stl.Object(sys.argv[1])
except:
    print "Error: cannot process input file '{}'.".format(sys.argv[1])
    print sys.exc_info()[0]
    usage()
    sys.exit(1)
# Remove spaces from name
stlobj.name = stlobj.name.strip()
# Calculate viewport and transformation
xmin,xmax,ymin,ymax,zmin,zmax = stlobj.extents()
pr = Zpar(xmin,xmax,ymin,ymax)
# Prepare output string.
outs = "%!PS-Adobe-1.0\n"
outs += "%%BoundingBox: 0 0 {:.0f} {:.0f}\n".format(pr.w, pr.h)
outs += "% Generated by {} on {}.\n".format(ver, time.asctime())
outs += "% Name of the solid: '{}'\n".format(stlobj.name)
outs += "% {} facets\n".format(len(stlobj))
outs += "% The scale factor used is: {} points/STL-unit\n".format(pr.s)
s = "% This becomes a picture of {:.0f}×{:.0f} points; {:.0f}×{:.0f} mm.\n"
outs += s.format(pr.w, pr.h, pr.w/72*25.4, pr.h/72*25.4)
outs += "% 3D Extents of the model:\n"
outs += "% {} ≤ x ≤ {}\n".format(xmin,xmax)
outs += "% {} ≤ y ≤ {}\n".format(ymin,ymax)
outs += "% {} ≤ z ≤ {}\n".format(zmin,zmax)
(x,y,z) = stlobj.center()
s = "% 3D center (midpoint of extents, STL units):\n% <{0}, {1}, {2}>\n"
outs += s.format(x, y, z)
# We need to sort the facets first.
sortedfacets = sorted(stlobj.facet,None, 
                      lambda f: math.fsum([f.v[0].z,f.v[1].z,f.v[2].z])/3)
# Draw the triangles
for f in sortedfacets:
    if pr.visible(f.n) == True:
        (x1,y1) = pr.xformv(f.v[0])
        (x2,y2) = pr.xformv(f.v[1])
        (x3,y3) = pr.xformv(f.v[2])
        outs += "{} {} moveto\n".format(x1,y1)
        outs += "{} {} lineto\n".format(x2,y2)
        outs += "{} {} lineto\n".format(x3,y3)
        outs += "closepath stroke\n".format(x3,y3)

# Showpage must be the last line in the PostScript output.
outs += "showpage\n"
# Send output.
if len(sys.argv) < 3:
    # To standard output.
    print outs
    sys.exit(0)
# Or to a named output file.
try:
    outf = open(sys.argv[2], "w+")
    outf.write(outs)
    outf.close()
except:
    print "Cannot write output file '{}'".format(sys.argv[2])
    sys.exit(2)
